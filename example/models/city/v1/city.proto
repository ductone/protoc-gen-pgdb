syntax = "proto3";

package models.city.v1;

import "dynamo/v1/dynamo.proto";
import "google/protobuf/timestamp.proto";
import "models/animals/v1/animals.proto";
import "models/zoo/v1/zoo.proto";
import "pgdb/v1/pgdb.proto";

option go_package = "github.com/ductone/protoc-gen-pgdb/example/models/city/v1";

message Attractions {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: [
      "id",
      "numid"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "furrrs"
    method: INDEX_METHOD_BTREE_GIN,
    columns: [
      "tenant_id",
      "zoo_shop.fur"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "nestednestednested"
    method: INDEX_METHOD_BTREE_GIN,
    columns: [
      "tenant_id",
      "zoo_shop.anything.sfixed_64"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "oneof"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "what"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "nested_oneof"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "zoo_shop.medium"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "medium_medium"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "medium.medium"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "petprofile"
    method: INDEX_METHOD_GIN,
    columns: [
      "tenant_id",
      "pet.profile"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "id"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "id"
    ]
  };
  string tenant_id = 1;
  string id = 2 [(pgdb.v1.options) = {full_text_type: FULL_TEXT_TYPE_EXACT}];
  int32 numid = 3;
  google.protobuf.Timestamp created_at = 4;
  oneof what {
    models.animals.v1.Pet pet = 10;
    models.zoo.v1.Shop zoo_shop = 11;
  }
  models.zoo.v1.Shop medium = 12;
  // This field tests the nested_only collision fix:
  // "Attractions" + "Config" = "AttractionsConfig" (same as the message type name)
  // Without the fix, this would cause duplicate type definitions.
  AttractionsConfig config = 13;
}

// A top-level nested_only message with a nested sub-message.
// Named to collide when embedded in Attractions: "Attractions" + "Config" = "AttractionsConfig"
message AttractionsConfig {
  option (pgdb.v1.msg).nested_only = true;

  message Detail {
    option (pgdb.v1.msg).nested_only = true;
    string info = 1;
  }
  Detail detail = 1;
  string name = 2;
}

// A second parent that also embeds AttractionsConfig (tests multi-embed scenario).
// "AttractionsV2" + "Config" = "AttractionsV2Config" which does NOT collide with "AttractionsConfig".
message AttractionsV2 {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  AttractionsConfig config = 3;
  google.protobuf.Timestamp created_at = 4;
}

// Test case for nested_only message with oneof embedded through multiple layers.
// This reproduces a bug where unsafe query builder children have wrong ParentTypeName.
message NestedOnlyWithOneof {
  option (pgdb.v1.msg).nested_only = true;

  message ChoiceA {
    option (pgdb.v1.msg).nested_only = true;
    string value_a = 1;
  }
  message ChoiceB {
    option (pgdb.v1.msg).nested_only = true;
    int32 value_b = 1;
  }

  oneof selector {
    ChoiceA choice_a = 1;
    ChoiceB choice_b = 2;
  }
}

// Middle layer - has database table, contains nested_only field with oneof
message NestedOnlyMiddle {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  NestedOnlyWithOneof oneof_field = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// Outer wrapper - embeds NestedOnlyMiddle to create the multi-layer nesting
message NestedOnlyWrapper {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  NestedOnlyMiddle middle = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// Test case for duplicate type generation bug.
// This structure causes both safe and unsafe query builders to have
// children with the same TypeName, which would cause duplicate type definitions.
message DuplicateTypeBugInner {
  option (pgdb.v1.msg).nested_only = true;
  string inner_value = 1;
}

message DuplicateTypeBugNested {
  option (pgdb.v1.msg).nested_only = true;
  string indexed_field = 1;
  string unindexed_field = 2;
  DuplicateTypeBugInner inner = 3;
}

message DuplicateTypeBugOuter {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  // Index on nested.indexed_field creates safe builder with UnsafeChildren
  option (pgdb.v1.msg).indexes = {
    name: "nested_indexed"
    method: INDEX_METHOD_BTREE
    columns: [
      "tenant_id",
      "nested.indexed_field"
    ]
  };
  string tenant_id = 1;
  string id = 2;
  DuplicateTypeBugNested nested = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// Test case: embedding a message that has its own DB type.
// This should NOT cause duplicate type generation because the
// parent should NOT traverse into messages with their own DB.
message EmbeddedDBInnerConfig {
  option (pgdb.v1.msg).nested_only = true;
  string value = 1;
}

message EmbeddedWithOwnDB {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  EmbeddedDBInnerConfig inner = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// Parent embeds EmbeddedWithOwnDB - should NOT generate types for EmbeddedWithOwnDB's children
// because EmbeddedWithOwnDB has its own DB type and will generate those types itself.
message ParentWithEmbeddedDB {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  EmbeddedWithOwnDB embedded = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// Test case for duplicate method generation (Bug 1)
// When a nested message has BOTH indexed AND non-indexed fields,
// the same UnsafeQueryBuilder children are accessible from both
// the safe QueryBuilder (via UnsafeChildren) and the UnsafeQueryBuilder (via Children).
// The child's field methods should only be generated once.
message DuplicateMethodsBugLeaf {
  option (pgdb.v1.msg).nested_only = true;
  string leaf_value = 1;
}

message DuplicateMethodsBugMiddle {
  option (pgdb.v1.msg).nested_only = true;
  string indexed_field = 1;
  string unindexed_field = 2;
  DuplicateMethodsBugLeaf leaf = 3;
}

message DuplicateMethodsBugRoot {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  option (pgdb.v1.msg).indexes = {
    name: "middle_indexed"
    method: INDEX_METHOD_BTREE
    columns: [
      "tenant_id",
      "middle.indexed_field"
    ]
  };
  string tenant_id = 1;
  string id = 2;
  DuplicateMethodsBugMiddle middle = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// Test case for duplicate type via different paths (Bug 2)
// When a grandchild type is reachable through different intermediate paths,
// it should only be generated once.
message DuplicateTypePathsBugGrandchild {
  option (pgdb.v1.msg).nested_only = true;
  string grandchild_value = 1;
}

message DuplicateTypePathsBugChildA {
  option (pgdb.v1.msg).nested_only = true;
  DuplicateTypePathsBugGrandchild nested = 1;
}

message DuplicateTypePathsBugChildB {
  option (pgdb.v1.msg).nested_only = true;
  DuplicateTypePathsBugGrandchild nested = 1;
}

message DuplicateTypePathsBugRoot {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  oneof selector {
    DuplicateTypePathsBugChildA child_a = 10;
    DuplicateTypePathsBugChildB child_b = 11;
  }
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}
