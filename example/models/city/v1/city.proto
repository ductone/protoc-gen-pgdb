syntax = "proto3";

package models.city.v1;

import "dynamo/v1/dynamo.proto";
import "google/protobuf/timestamp.proto";
import "models/animals/v1/animals.proto";
import "models/zoo/v1/zoo.proto";
import "pgdb/v1/pgdb.proto";

option go_package = "github.com/ductone/protoc-gen-pgdb/example/models/city/v1";

message Attractions {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: [
      "id",
      "numid"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "furrrs"
    method: INDEX_METHOD_BTREE_GIN,
    columns: [
      "tenant_id",
      "zoo_shop.fur"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "nestednestednested"
    method: INDEX_METHOD_BTREE_GIN,
    columns: [
      "tenant_id",
      "zoo_shop.anything.sfixed_64"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "oneof"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "what"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "nested_oneof"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "zoo_shop.medium"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "medium_medium"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "medium.medium"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "petprofile"
    method: INDEX_METHOD_GIN,
    columns: [
      "tenant_id",
      "pet.profile"
    ]
  };
  option (pgdb.v1.msg).indexes = {
    name: "id"
    method: INDEX_METHOD_BTREE,
    columns: [
      "tenant_id",
      "id"
    ]
  };
  string tenant_id = 1;
  string id = 2 [(pgdb.v1.options) = {full_text_type: FULL_TEXT_TYPE_EXACT}];
  int32 numid = 3;
  google.protobuf.Timestamp created_at = 4;
  oneof what {
    models.animals.v1.Pet pet = 10;
    models.zoo.v1.Shop zoo_shop = 11;
  }
  models.zoo.v1.Shop medium = 12;
  // This field tests the nested_only collision fix:
  // "Attractions" + "Config" = "AttractionsConfig" (same as the message type name)
  // Without the fix, this would cause duplicate type definitions.
  AttractionsConfig config = 13;
}

// A top-level nested_only message with a nested sub-message.
// Named to collide when embedded in Attractions: "Attractions" + "Config" = "AttractionsConfig"
message AttractionsConfig {
  option (pgdb.v1.msg).nested_only = true;

  message Detail {
    option (pgdb.v1.msg).nested_only = true;
    string info = 1;
  }
  Detail detail = 1;
  string name = 2;
}

// A second parent that also embeds AttractionsConfig (tests multi-embed scenario).
// "AttractionsV2" + "Config" = "AttractionsV2Config" which does NOT collide with "AttractionsConfig".
message AttractionsV2 {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  AttractionsConfig config = 3;
  google.protobuf.Timestamp created_at = 4;
}

// Test case for nested_only message with oneof embedded through multiple layers.
// This reproduces a bug where unsafe query builder children have wrong ParentTypeName.
message NestedOnlyWithOneof {
  option (pgdb.v1.msg).nested_only = true;

  message ChoiceA {
    option (pgdb.v1.msg).nested_only = true;
    string value_a = 1;
  }
  message ChoiceB {
    option (pgdb.v1.msg).nested_only = true;
    int32 value_b = 1;
  }

  oneof selector {
    ChoiceA choice_a = 1;
    ChoiceB choice_b = 2;
  }
}

// Middle layer - has database table, contains nested_only field with oneof
message NestedOnlyMiddle {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  NestedOnlyWithOneof oneof_field = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}

// Outer wrapper - embeds NestedOnlyMiddle to create the multi-layer nesting
message NestedOnlyWrapper {
  option (dynamo.v1.msg).key = {
    pk_fields: ["tenant_id"]
    sk_fields: ["id"]
  };
  string tenant_id = 1;
  string id = 2;
  NestedOnlyMiddle middle = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
}
